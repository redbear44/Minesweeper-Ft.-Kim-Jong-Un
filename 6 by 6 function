import pygame, sys
import random
import time
import os

RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
HOTPINK = (244, 66, 182)
GREY = (73, 73, 73)
LIGHTGREY = (160, 160, 160)
YELLOW = (255, 251, 35)
LIGHTBLUE = (66, 134, 244)
FUCHSIA = (255, 0, 255)
PURPLE = (128, 0, 128)
FLOURESCENTGREEN = (63, 255, 0)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BIGRED = (206, 16, 16)

BGCOLOR = WHITE
FIELDCOLOR = BLACK
BOXCOLOR_COV = DARKGRAY # covered box color
BOXCOLOR_REV = LIGHTGRAY # revealed box color
MINECOLOR = BLACK
TEXTCOLOR_1 = BLUE
TEXTCOLOR_2 = RED
TEXTCOLOR_3 = BLACK
HILITECOLOR = GREEN
RESETBGCOLOR = LIGHTGRAY
MINEMARK_COV = RED

windowWidth = 1200
windowHeight = 650
xMargin = int((windowWidth- (fieldWidth*(boxSize + gapSize))))
yMargin = xMargin
minesTotal = int()
def field():

   # creates blank FIELDWIDTH x FIELDHEIGHT data structure

    field = []
    for x in range(fieldWidth):
        field.append([])
        for y in range(fieldHeight):
            field[x].append('[ ]')
    return

def placeMines(field):

    # places mines in FIELDWIDTH x FIELDHEIGHT data structure
    # requires blank field as input

    mineCount = 0
    xy = []
    while mineCount < minesTotal:
        x = random.randint(0,fieldWidth-1)
        y = random.randint(0,fieldHeight-1)
        xy.append([x,y])
        if xy.count([x,y]) > 1:
            xy.remove([x,y])
        else:
            field[x][y] = '[X]'
            mineCount += 1

def isThereMine(field, x, y):

    # checks if mine is located at specific box on field

    return field[x][y] == '[X]'

def drawField():

    # draws field GUI and reset button

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            left, top = getLeftAndTopXY(box_x, box_y)
            pygame.draw.rect(screen, BLUE, (left, top, boxSize, boxSize))

    screen.blit(RESET_SURF, RESET_RECT)
    screen.blit(SHOW_SURF, SHOW_RECT)

def getLeftAndTopXY(box_x, box_y):

    # get left & top coordinates for drawing mine boxes

    left = xMargin + box_x*(boxSize+gapSize)
    top = yMargin + box_y*(boxSize+gapSize)
    return left, top

def placeNumbers(field):

    # places numbers in FIELDWIDTH x FIELDHEIGHT data structure
    # requires field with mines as input

    for x in range(FIELDWIDTH):
        for y in range(FIELDHEIGHT):
            if not isThereMine(field, x, y):
                count = 0
                if x != 0:
                    if isThereMine(field, x-1, y):
                        count += 1
                    if y != 0:
                        if isThereMine(field, x-1, y-1):
                            count += 1
                    if y != FIELDHEIGHT-1:
                        if isThereMine(field, x-1, y+1):
                            count += 1
                if x != FIELDWIDTH-1:
                    if isThereMine(field, x+1, y):
                        count += 1
                    if y != 0:
                        if isThereMine(field, x+1, y-1):
                            count += 1
                    if y != FIELDHEIGHT-1:
                        if isThereMine(field, x+1, y+1):
                            count += 1
                if y != 0:
                    if isThereMine(field, x, y-1):
                        count += 1
                if y != FIELDHEIGHT-1:
                    if isThereMine(field, x, y+1):
                        count += 1
                field[x][y] = '[%s]' %(count)

def blankRevealedBoxData(val):

    # returns FIELDWIDTH x FIELDHEIGHT data structure different from the field data structure
    # each item in data structure is boolean (val) to show whether box at those fieldwidth & fieldheight coordinates should be revealed

    revealedBoxes = []
    for i in range(FIELDWIDTH):
        revealedBoxes.append([val] * FIELDHEIGHT)
    return revealedBoxes

def gameSetup():

    # set up mine field data structure, list of all zeros for recursion, and revealed box boolean data structure

    mineField = blankField()
    placeMines(mineField)
    placeNumbers(mineField)
    zeroListXY = []
    markedMines = []
    revealedBoxes = blankRevealedBoxData(False)

    return mineField, zeroListXY, revealedBoxes, markedMines


def drawMinesNumbers(field):
    # draws mines and numbers onto GUI
    # field should have mines and numbers

    half = int(BOXSIZE * 0.5)
    quarter = int(BOXSIZE * 0.25)
    eighth = int(BOXSIZE * 0.125)

    for box_x in range(FIELDWIDTH):
        for box_y in range(FIELDHEIGHT):
            left, top = getLeftTopXY(box_x, box_y)
            center_x, center_y = getCenterXY(box_x, box_y)
            if field[box_x][box_y] == '[X]':
                pygame.draw.circle(DISPLAYSURFACE, MINECOLOR, (left + half, top + half), quarter)
                pygame.draw.circle(DISPLAYSURFACE, WHITE, (left + half, top + half), eighth)
                pygame.draw.line(DISPLAYSURFACE, MINECOLOR, (left + eighth, top + half),
                                 (left + half + quarter + eighth, top + half))
                pygame.draw.line(DISPLAYSURFACE, MINECOLOR, (left + half, top + eighth),
                                 (left + half, top + half + quarter + eighth))
                pygame.draw.line(DISPLAYSURFACE, MINECOLOR, (left + quarter, top + quarter),
                                 (left + half + quarter, top + half + quarter))
                pygame.draw.line(DISPLAYSURFACE, MINECOLOR, (left + quarter, top + half + quarter),
                                 (left + half + quarter, top + quarter))
            else:
                for i in range(1, 9):
                    if field[box_x][box_y] == '[' + str(i) + ']':
                        if i in range(1, 3):
                            textColor = TEXTCOLOR_1
                        else:
                            textColor = TEXTCOLOR_2
                        drawText(str(i), BASICFONT, textColor, DISPLAYSURFACE, center_x, center_y)


def showNumbers(revealedBoxes, mineField, box_x, box_y, zeroListXY):
    # modifies revealedBox data strucure if chosen box_x & box_y is [0]
    # show all boxes using recursion

    revealedBoxes[box_x][box_y] = True
    revealAdjacentBoxes(revealedBoxes, box_x, box_y)
    for i, j in getAdjacentBoxesXY(mineField, box_x, box_y):
        if mineField[i][j] == '[0]' and [i, j] not in zeroListXY:
            zeroListXY.append([i, j])
            showNumbers(revealedBoxes, mineField, i, j, zeroListXY)

def showMines(revealedBoxes, mineField, box_x, box_y):

    # modifies revealedBox data strucure if chosen box_x & box_y is [X]

    for i in range(FIELDWIDTH):
        for j in range(FIELDHEIGHT):
            if mineField[i][j] == '[X]':
                revealedBoxes[i][j] = True

def revealAdjacentBoxes(revealedBoxes, box_x, box_y):

    # modifies revealedBoxes data structure so that all adjacent boxes to (box_x, box_y) are set to True

    if box_x != 0:
        revealedBoxes[box_x-1][box_y] = True
        if box_y != 0:
            revealedBoxes[box_x-1][box_y-1] = True
        if box_y != FIELDHEIGHT-1:
            revealedBoxes[box_x-1][box_y+1] = True
    if box_x != FIELDWIDTH-1:
        revealedBoxes[box_x+1][box_y] = True
        if box_y != 0:
            revealedBoxes[box_x+1][box_y-1] = True
        if box_y != FIELDHEIGHT-1:
            revealedBoxes[box_x+1][box_y+1] = True
    if box_y != 0:
        revealedBoxes[box_x][box_y-1] = True
    if box_y != FIELDHEIGHT-1:
        revealedBoxes[box_x][box_y+1] = True

def getAdjacentBoxesXY(mineField, box_x, box_y):

    # get box XY coordinates for all adjacent boxes to (box_x, box_y)

    adjacentBoxesXY = []

    if box_x != 0:
        adjacentBoxesXY.append([box_x-1,box_y])
        if box_y != 0:
            adjacentBoxesXY.append([box_x-1,box_y-1])
        if box_y != FIELDHEIGHT-1:
            adjacentBoxesXY.append([box_x-1,box_y+1])
    if box_x != FIELDWIDTH-1:
        adjacentBoxesXY.append([box_x+1,box_y])
        if box_y != 0:
            adjacentBoxesXY.append([box_x+1,box_y-1])
        if box_y != FIELDHEIGHT-1:
            adjacentBoxesXY.append([box_x+1,box_y+1])
    if box_y != 0:
        adjacentBoxesXY.append([box_x,box_y-1])
    if box_y != FIELDHEIGHT-1:
        adjacentBoxesXY.append([box_x,box_y+1])

    return adjacentBoxesXY

def drawCovers(revealedBoxes, markedMines):

    # uses revealedBox FIELDWIDTH x FIELDHEIGHT data structure to determine whether to draw box covering mine/number
    # draw red cover instead of gray cover over marked mines

    for box_x in range(FIELDWIDTH):
        for box_y in range(FIELDHEIGHT):
            if not revealedBoxes[box_x][box_y]:
                left, top = getLeftTopXY(box_x, box_y)
                if [box_x, box_y] in markedMines:
                    pygame.draw.rect(DISPLAYSURFACE, MINEMARK_COV, (left, top, BOXSIZE, BOXSIZE))
                else:
                    pygame.draw.rect(DISPLAYSURFACE, BOXCOLOR_COV, (left, top, BOXSIZE, BOXSIZE))

def drawText(text, font, color, surface, x, y):

    # function to easily draw text and also return object & rect pair

    textobj = font.render(text, True, color)
    textrect = textobj.get_rect()
    textrect.centerx = x
    textrect.centery = y
    surface.blit(textobj, textrect)

def drawButton(text, color, bgcolor, center_x, center_y):

    # similar to drawText but text has bg color and returns obj & rect

    butSurf = BASICFONT.render(text, True, color, bgcolor)
    butRect = butSurf.get_rect()
    butRect.centerx = center_x
    butRect.centery = center_y
    return (butSurf, butRect)

def getLeftTopXY(box_x, box_y):

    # get left & top coordinates for drawing mine boxes

    left = XMARGIN + box_x*(BOXSIZE+GAPSIZE)
    top = YMARGIN + box_y*(BOXSIZE+GAPSIZE)
    return left, top


def getCenterXY(box_x, box_y):
    # get center coordinates for drawing mine boxes

    center_x = XMARGIN + BOXSIZE / 2 + box_x * (BOXSIZE + GAPSIZE)
    center_y = YMARGIN + BOXSIZE / 2 + box_y * (BOXSIZE + GAPSIZE)
    return center_x, center_y


def getBoxAtPixel(x, y):
    # gets coordinates of box at mouse coordinates

    for box_x in range(FIELDWIDTH):
        for box_y in range(FIELDHEIGHT):
            left, top = getLeftTopXY(box_x, box_y)
            boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE)
            if boxRect.collidepoint(x, y):
                return (box_x, box_y)
    return (None, None)


def highlightBox(box_x, box_y):
    # highlight box when mouse hovers over it

    left, top = getLeftTopXY(box_x, box_y)
    pygame.draw.rect(DISPLAYSURFACE, HILITECOLOR, (left, top, BOXSIZE, BOXSIZE), 4)


def highlightButton(butRect):
    # highlight button when mouse hovers over it

    linewidth = 4
    pygame.draw.rect(DISPLAYSURFACE, HILITECOLOR, (
    butRect.left - linewidth, butRect.top - linewidth, butRect.width + 2 * linewidth, butRect.height + 2 * linewidth),
                     linewidth)


def gameWon(revealedBoxes, mineField):
    # check if player has revealed all boxes

    notMineCount = 0

    for box_x in range(FIELDWIDTH):
        for box_y in range(FIELDHEIGHT):
            if revealedBoxes[box_x][box_y] == True:
                if mineField[box_x][box_y] != '[X]':
                    notMineCount += 1

    if notMineCount >= (FIELDWIDTH * FIELDHEIGHT) - MINESTOTAL:
        return True
    else:
        return False


def terminate():
    # simple function to exit game

    pygame.quit()
    sys.exit()


def checkForKeyPress():
    # check if quit or any other key is pressed

    if len(pygame.event.get(QUIT)) > 0:
        terminate()

    keyUpEvents = pygame.event.get(KEYUP)
    if len(keyUpEvents) == 0:
        return None
    if keyUpEvents[0].key == K_ESCAPE:
        terminate()
    return keyUpEvents[0].key



def sixXsix():
    screen.fill(BLUE)
    while True:
        mouseClicked = False
        spacePressed = False

        pygame.draw.rect(screen, WHITE, [475, 200, 240, 240])
        

        pygame.display.update()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()


if __name__ == '__main__':
    running = True
    pygame.init()
    screen = pygame.display.set_mode((1200, 650))
    screen_rect = screen.get_rect()
    clock = pygame.time.Clock()
    timer = 0
    bg = (random.randint(100, 220), random.randint(100, 220), random.randint(100, 220) != (0, 0, 0) != (255, 255, 255))


    font = pygame.font.SysFont("comicsansms", 35)

    assert MINESTOTAL < FIELDHEIGHT * FIELDWIDTH, 'More mines than boxes'
    assert BOXSIZE ^ 2 * (FIELDHEIGHT * FIELDWIDTH) < WINDOWHEIGHT * WINDOWWIDTH, 'Boxes will not fit on screen'
    assert BOXSIZE / 2 > 5, 'Bounding errors when drawing rectangle, cannot use half-5 in drawMinesNumbers'

    rectx = 475
    recty = 250
    rectchangex = 5
    rectchangey = 5
    pygame.draw.rect(screen, BLACK, [rectx, recty, 250, 151], 2)  # selection screen
    pygame.display.set_caption("Mine Sweeper Feat. Kim Jong Un")


while running:
    sixXsix()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    if pygame.time.get_ticks() - timer > 300:  # change the number value to change how long a color lasts on the page
        timer = pygame.time.get_ticks()
        bg = (
        random.randint(100, 220), random.randint(100, 220), random.randint(100, 220) != (0, 0, 0) != (255, 255, 255))
    pygame.display.update()
    clock.tick(60)  # fps (60 is fine but could be reduced if lagging because minesweeper doesn't really refresh a lot

