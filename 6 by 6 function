import pygame, sys
import random
import time
import os

RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
HOTPINK = (244, 66, 182)
GREY = (73, 73, 73)
DARKGREY = (40, 40, 40)
LIGHTGREY = (160, 160, 160)
YELLOW = (255, 251, 35)
LIGHTBLUE = (66, 134, 244)
FUCHSIA = (255, 0, 255)
PURPLE = (128, 0, 128)
FLOURESCENTGREEN = (63, 255, 0)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BIGRED = (206, 16, 16)

BGCOLOR = WHITE
FIELDCOLOR = BLACK
BOXCOLOR_COV = DARKGREY # covered box color
BOXCOLOR_REV = LIGHTGREY # revealed box color
MINECOLOR = BLACK
TEXTCOLOR_1 = BLUE
TEXTCOLOR_2 = RED
TEXTCOLOR_3 = BLACK
HILITECOLOR = GREEN
RESETBGCOLOR = LIGHTGREY
MINEMARK_COV = RED
FONTTYPE = 'Courier New'
FONTSIZE = 20
windowWidth = 1200
boxSize = 30
windowHeight = 650
fieldWidth = 20
fieldHeight = 20
gapSize = 5

def drawButton(text, color, bgcolor, center_x, center_y):

    # similar to drawText but text has bg color and returns obj & rect

    butSurf = font.render(text, True, color, bgcolor)
    butRect = butSurf.get_rect()
    butRect.centerx = center_x
    butRect.centery = center_y
    return (butSurf, butRect)

global fpsClock, screen, font, resetSurf, resetRect, showSurf, showRect
pygame.init()
pygame.display.set_caption('Minesweeper')
fpsClock = pygame.time.Clock()
screen = pygame.display.set_mode((windowWidth, windowHeight))
font = pygame.font.SysFont(FONTTYPE, FONTSIZE)

# obtain reset & show objects and rects
resetSurf, resetRect = drawButton('RESET', TEXTCOLOR_3, RESETBGCOLOR, windowWidth / 2, windowHeight - 120)
showSurf, showRect = drawButton('SHOW ALL', TEXTCOLOR_3, RESETBGCOLOR, windowWidth / 2, windowHeight - 95)


xMargin = int((windowWidth- (fieldWidth*(boxSize + gapSize))))
yMargin = xMargin
minesTotal = int()
def field():

   # creates blank fieldWidth x fieldHeight data structure

    field = []
    for x in range(fieldWidth):
        field.append([])
        for y in range(fieldHeight):
            field[x].append('[ ]')
    return

def placeMines(field):

    # places mines in fieldWidth x fieldHeight data structure
    # requires blank field as input

    mineCount = 0
    xy = []
    while mineCount < minesTotal:
        x = random.randint(0,fieldWidth-1)
        y = random.randint(0,fieldHeight-1)
        xy.append([x,y])
        if xy.count([x,y]) > 1:
            xy.remove([x,y])
        else:
            field[x][y] = '[X]'
            mineCount += 1

def isThereMine(field, x, y):

    # checks if mine is located at specific box on field

    return field[x][y] == '[X]'

def drawField():

    # draws field GUI and reset button

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            left, top = getLeftAndTopXY(box_x, box_y)
            pygame.draw.rect(screen, BLUE, (left, top, boxSize, boxSize))

    screen.blit(resetSurf, resetRect)
    screen.blit(showSurf, showRect)

def getLeftAndTopXY(box_x, box_y):

    # get left & top coordinates for drawing mine boxes

    left = xMargin + box_x*(boxSize+gapSize)
    top = yMargin + box_y*(boxSize+gapSize)
    return left, top

def placeNumbers(field):

    # places numbers in fieldWidth x fieldHeight data structure
    # requires field with mines as input

    for x in range(fieldWidth):
        for y in range(fieldHeight):
            if not isThereMine(field, x, y):
                count = 0
                if x != 0:
                    if isThereMine(field, x-1, y):
                        count += 1
                    if y != 0:
                        if isThereMine(field, x-1, y-1):
                            count += 1
                    if y != fieldHeight-1:
                        if isThereMine(field, x-1, y+1):
                            count += 1
                if x != fieldWidth-1:
                    if isThereMine(field, x+1, y):
                        count += 1
                    if y != 0:
                        if isThereMine(field, x+1, y-1):
                            count += 1
                    if y != fieldHeight-1:
                        if isThereMine(field, x+1, y+1):
                            count += 1
                if y != 0:
                    if isThereMine(field, x, y-1):
                        count += 1
                if y != fieldHeight-1:
                    if isThereMine(field, x, y+1):
                        count += 1
                field[x][y] = '[%s]' %(count)

def blankRevealedBoxData(val):

    # returns fieldWidth x fieldHeight data structure different from the field data structure
    # each item in data structure is boolean (val) to show whether box at those fieldWidth & fieldHeight coordinates should be revealed

    revealedBoxes = []
    for i in range(fieldWidth):
        revealedBoxes.append([val] * fieldHeight)
    return revealedBoxes

def gameSetup():

    # set up mine field data structure, list of all zeros for recursion, and revealed box boolean data structure

    mineField = field()
    placeMines(mineField)
    placeNumbers(mineField)
    zeroListXY = []
    markedMines = []
    revealedBoxes = blankRevealedBoxData(False)

    return mineField, zeroListXY, revealedBoxes, markedMines


def drawMinesNumbers(field):
    # draws mines and numbers onto GUI
    # field should have mines and numbers

    half = int(boxSize * 0.5)
    quarter = int(boxSize * 0.25)
    eighth = int(boxSize * 0.125)

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            left, top = getLeftTopXY(box_x, box_y)
            center_x, center_y = getCenterXY(box_x, box_y)
            if field[box_x][box_y] == '[X]':
                pygame.draw.circle(screen, MINECOLOR, (left + half, top + half), quarter)
                pygame.draw.circle(screen, WHITE, (left + half, top + half), eighth)
                pygame.draw.line(screen, MINECOLOR, (left + eighth, top + half),
                                 (left + half + quarter + eighth, top + half))
                pygame.draw.line(screen, MINECOLOR, (left + half, top + eighth),
                                 (left + half, top + half + quarter + eighth))
                pygame.draw.line(screen, MINECOLOR, (left + quarter, top + quarter),
                                 (left + half + quarter, top + half + quarter))
                pygame.draw.line(screen, MINECOLOR, (left + quarter, top + half + quarter),
                                 (left + half + quarter, top + quarter))
            else:
                for i in range(1, 9):
                    if field[box_x][box_y] == '[' + str(i) + ']':
                        if i in range(1, 3):
                            textColor = TEXTCOLOR_1
                        else:
                            textColor = TEXTCOLOR_2
                        drawText(str(i), font, textColor, screen, center_x, center_y)


def showNumbers(revealedBoxes, mineField, box_x, box_y, zeroListXY):
    # modifies revealedBox data strucure if chosen box_x & box_y is [0]
    # show all boxes using recursion

    revealedBoxes[box_x][box_y] = True
    revealAdjacentBoxes(revealedBoxes, box_x, box_y)
    for i, j in getAdjacentBoxesXY(mineField, box_x, box_y):
        if mineField[i][j] == '[0]' and [i, j] not in zeroListXY:
            zeroListXY.append([i, j])
            showNumbers(revealedBoxes, mineField, i, j, zeroListXY)

def showMines(revealedBoxes, mineField, box_x, box_y):

    # modifies revealedBox data strucure if chosen box_x & box_y is [X]

    for i in range(fieldWidth):
        for j in range(fieldHeight):
            if mineField[i][j] == '[X]':
                revealedBoxes[i][j] = True

def revealAdjacentBoxes(revealedBoxes, box_x, box_y):

    # modifies revealedBoxes data structure so that all adjacent boxes to (box_x, box_y) are set to True

    if box_x != 0:
        revealedBoxes[box_x-1][box_y] = True
        if box_y != 0:
            revealedBoxes[box_x-1][box_y-1] = True
        if box_y != fieldHeight-1:
            revealedBoxes[box_x-1][box_y+1] = True
    if box_x != fieldWidth-1:
        revealedBoxes[box_x+1][box_y] = True
        if box_y != 0:
            revealedBoxes[box_x+1][box_y-1] = True
        if box_y != fieldHeight-1:
            revealedBoxes[box_x+1][box_y+1] = True
    if box_y != 0:
        revealedBoxes[box_x][box_y-1] = True
    if box_y != fieldHeight-1:
        revealedBoxes[box_x][box_y+1] = True

def getAdjacentBoxesXY(mineField, box_x, box_y):

    # get box XY coordinates for all adjacent boxes to (box_x, box_y)

    adjacentBoxesXY = []

    if box_x != 0:
        adjacentBoxesXY.append([box_x-1,box_y])
        if box_y != 0:
            adjacentBoxesXY.append([box_x-1,box_y-1])
        if box_y != fieldHeight-1:
            adjacentBoxesXY.append([box_x-1,box_y+1])
    if box_x != fieldWidth-1:
        adjacentBoxesXY.append([box_x+1,box_y])
        if box_y != 0:
            adjacentBoxesXY.append([box_x+1,box_y-1])
        if box_y != fieldHeight-1:
            adjacentBoxesXY.append([box_x+1,box_y+1])
    if box_y != 0:
        adjacentBoxesXY.append([box_x,box_y-1])
    if box_y != fieldHeight-1:
        adjacentBoxesXY.append([box_x,box_y+1])

    return adjacentBoxesXY

def drawCovers(revealedBoxes, markedMines):

    # uses revealedBox fieldWidth x fieldHeight data structure to determine whether to draw box covering mine/number
    # draw red cover instead of gray cover over marked mines

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            if not revealedBoxes[box_x][box_y]:
                left, top = getLeftTopXY(box_x, box_y)
                if [box_x, box_y] in markedMines:
                    pygame.draw.rect(screen, MINEMARK_COV, (left, top, boxSize, boxSize))
                else:
                    pygame.draw.rect(screen, BOXCOLOR_COV, (left, top, boxSize, boxSize))

def drawText(text, font, color, surface, x, y):

    # function to easily draw text and also return object & rect pair

    textobj = font.render(text, True, color)
    textrect = textobj.get_rect()
    textrect.centerx = x
    textrect.centery = y
    surface.blit(textobj, textrect)


def getLeftTopXY(box_x, box_y):

    # get left & top coordinates for drawing mine boxes

    left = xMargin + box_x*(boxSize+gapSize)
    top = yMargin + box_y*(boxSize+gapSize)
    return left, top


def getCenterXY(box_x, box_y):
    # get center coordinates for drawing mine boxes

    center_x = xMargin + boxSize / 2 + box_x * (boxSize + gapSize)
    center_y = yMargin + boxSize / 2 + box_y * (boxSize + gapSize)
    return center_x, center_y


def getBoxAtPixel(x, y):
    # gets coordinates of box at mouse coordinates

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            left, top = getLeftTopXY(box_x, box_y)
            boxRect = pygame.Rect(left, top, boxSize, boxSize)
            if boxRect.collidepoint(x, y):
                return (box_x, box_y)
    return (None, None)


def highlightBox(box_x, box_y):
    # highlight box when mouse hovers over it

    left, top = getLeftTopXY(box_x, box_y)
    pygame.draw.rect(screen, HILITECOLOR, (left, top, boxSize, boxSize), 4)


def highlightButton(butRect):
    # highlight button when mouse hovers over it

    linewidth = 4
    pygame.draw.rect(screen, HILITECOLOR, (
    butRect.left - linewidth, butRect.top - linewidth, butRect.width + 2 * linewidth, butRect.height + 2 * linewidth),
                     linewidth)


def gameWon(revealedBoxes, mineField):
    # check if player has revealed all boxes

    notMineCount = 0

    for box_x in range(fieldWidth):
        for box_y in range(fieldHeight):
            if revealedBoxes[box_x][box_y] == True:
                if mineField[box_x][box_y] != '[X]':
                    notMineCount += 1

    if notMineCount >= (fieldWidth * fieldHeight) - minesTotal:
        return True
    else:
        return False


def terminate():
    # simple function to exit game

    pygame.quit()
    sys.exit()


def checkForKeyPress():
    # check if quit or any other key is pressed

    if len(pygame.event.get(QUIT)) > 0:
        terminate()

    keyUpEvents = pygame.event.get(KEYUP)
    if len(keyUpEvents) == 0:
        return None
    if keyUpEvents[0].key == K_ESCAPE:
        terminate()
    return keyUpEvents[0].key



def main():


    # obtain reset & show objects and rects
    resetRect , resetRect = drawButton('RESET', TEXTCOLOR_3, RESETBGCOLOR, windowWidth / 2, windowHeight - 120)
    showSurf, showRect = drawButton('SHOW ALL', TEXTCOLOR_3, RESETBGCOLOR, windowWidth / 2, windowHeight - 95)

    # stores XY of mouse events
    mouse_x = 0
    mouse_y = 0

    # set up data structures and lists
    mineField, zeroListXY, revealedBoxes, markedMines = gameSetup()

    # set background color
    DISPLAYSURFACE.fill(BGCOLOR)

    # main game loop
    while True:

        # check for quit function
        checkForKeyPress()

        # initialize input booleans
        mouseClicked = False
        spacePressed = False

        # draw field
        DISPLAYSURFACE.fill(BGCOLOR)
        pygame.draw.rect(screen, FIELDCOLOR, (
        xMargin - 5, YMARGIN - 5, (boxSize + gapSize) * FIELDWIDTH + 5, (BOXSIZE + GAPSIZE) * FIELDHEIGHT + 5))
        drawField()
        drawMinesNumbers(mineField)

        # event handling loop
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):
                terminate()
            elif event.type == MOUSEMOTION:
                mouse_x, mouse_y = event.pos
            elif event.type == MOUSEBUTTONDOWN:
                mouse_x, mouse_y = event.pos
                mouseClicked = True
            elif event.type == KEYDOWN:
                if event.key == K_SPACE:
                    spacePressed = True
            elif event.type == KEYUP:
                if event.key == K_SPACE:
                    spacePressed = False

        # draw covers
        drawCovers(revealedBoxes, markedMines)

        # mine marker tip
        tipFont = pygame.font.SysFont(FONTTYPE, 16)  ## not using BASICFONT - too big
        drawText('Tip: Highlight a box and press space (rather than click the mouse)', tipFont, TEXTCOLOR_3,
                 DISPLAYSURFACE, windowWidth / 2, windowHeight - 60)
        drawText('to mark areas that you think contain mines.', tipFont, TEXTCOLOR_3, DISPLAYSURFACE, windowWidth / 2,
                 windowHeight - 40)

        # determine boxes at clicked areas
        box_x, box_y = getBoxAtPixel(mouse_x, mouse_y)

        # mouse not over a box in field
        if (box_x, box_y) == (None, None):

            # check if reset box is clicked
            if resetRect.collidepoint(mouse_x, mouse_y):
                highlightButton(resetRect)
                if mouseClicked:
                    mineField, zeroListXY, revealedBoxes, markedMines = gameSetup()

            # check if show box is clicked
            if showRect.collidepoint(mouse_x, mouse_y):
                highlightButton(showRect)
                if mouseClicked:
                    revealedBoxes = blankRevealedBoxData(True)

        # mouse currently over box in field
        else:

            # highlight unrevealed box
            if not revealedBoxes[box_x][box_y]:
                highlightBox(box_x, box_y)

                # mark mines
                if spacePressed:
                    markedMines.append([box_x, box_y])

                # reveal clicked boxes
                if mouseClicked:
                    revealedBoxes[box_x][box_y] = True

                    # when 0 is revealed, show relevant boxes
                    if mineField[box_x][box_y] == '[0]':
                        showNumbers(revealedBoxes, mineField, box_x, box_y, zeroListXY)

                    # when mine is revealed, show mines
                    if mineField[box_x][box_y] == '[X]':
                        showMines(revealedBoxes, mineField, box_x, box_y)
                        gameOverAnimation(mineField, revealedBoxes, markedMines, 'LOSS')
                        mineField, zeroListXY, revealedBoxes, markedMines = gameSetup()

        # check if player has won
        if gameWon(revealedBoxes, mineField):
            gameOverAnimation(mineField, revealedBoxes, markedMines, 'WIN')
            mineField, zeroListXY, revealedBoxes, markedMines = gameSetup()

        # redraw screen, wait clock tick
        pygame.display.update()
        fpsCLock.tick(fps)

if __name__ == '__main__':
    running = True
    pygame.init()
    screen = pygame.display.set_mode((1200, 650))
    screen_rect = screen.get_rect()
    clock = pygame.time.Clock()
    timer = 0
    bg = (random.randint(100, 220), random.randint(100, 220), random.randint(100, 220) != (0, 0, 0) != (255, 255, 255))


    font = pygame.font.SysFont("comicsansms", 35)

    assert minesTotal < fieldHeight * fieldWidth, 'More mines than boxes'
    assert boxSize ^ 2 * (fieldHeight * fieldWidth) < windowHeight * windowWidth, 'Boxes will not fit on screen'
    assert boxSize / 2 > 5, 'Bounding errors when drawing rectangle, cannot use half-5 in drawMinesNumbers'

    rectx = 475
    recty = 250
    rectchangex = 5
    rectchangey = 5
    pygame.draw.rect(screen, BLACK, [rectx, recty, 250, 151], 2)  # selection screen
    pygame.display.set_caption("Mine Sweeper Feat. Kim Jong Un")


while running:
    main()
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    if pygame.time.get_ticks() - timer > 300:  # change the number value to change how long a color lasts on the page
        timer = pygame.time.get_ticks()
        bg = (
        random.randint(100, 220), random.randint(100, 220), random.randint(100, 220) != (0, 0, 0) != (255, 255, 255))
    pygame.display.update()
    clock.tick(60)  # fps (60 is fine but could be reduced if lagging because minesweeper doesn't really refresh a lot
